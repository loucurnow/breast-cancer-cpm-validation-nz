objective = "survival:cox",
nthread = nthread,
eval_metric = "cox-nloglik"
)
#use 70% of dataset as training set and 30% as test set
sample <- sample(c(TRUE, FALSE), nrow(data), replace=TRUE, prob=c(0.7,0.3))
data.train  <- as.matrix(data[sample, ])
data.test   <- as.matrix(data[!sample, ])
data.train.predictors = subset(data.train, select = c(age, menopause, size, grade, nodes, er, pr, year))
data.train.label = as.numeric(data.train[,"survtime"])
dmatrix_train <- xgb.DMatrix(data.train.predictors, label=data.train.label, nthread = 1)
# create model from training data
cv <- xgb.cv(
params = xgb.params,
data = dmatrix_train,
nrounds = 500,
nfold = 5,
early_stopping_rounds = 10,
verbose = 1,
showsd = TRUE,
print_every_n = 10
)
best_nrounds <- cv$best_iteration
booster <- xgb.train(
data = dmatrix_train,
nrounds = best_nrounds,
params = xgb.params
)
# testing
data.test.predictors = subset(data.test, select = c(age, menopause, size, grade, nodes, er, pr, year))
data.test.label = as.numeric(data.test[,"survtime"])
dmatrix_test <- xgb.DMatrix(data.test.predictors, label=data.test.label, nthread = nthread)
# predicting
xgb.importance(model=booster)
booster
xgb.params <- list(
booster = "gbtree",
eta = 0.05,
max_depth = 4,
gamma = 0.1,
subsample = 0.75,
colsample_bytree = 0.8,
objective = "survival:cox",
nthread = nthread,
eval_metric = "cox-nloglik"
)
#use 70% of dataset as training set and 30% as test set
sample <- sample(c(TRUE, FALSE), nrow(data), replace=TRUE, prob=c(0.7,0.3))
data.train  <- as.matrix(data[sample, ])
data.test   <- as.matrix(data[!sample, ])
data.train.predictors = subset(data.train, select = c(age, menopause, size, grade, nodes, er, pr, year))
data.train.label = as.numeric(data.train[,"survtime"])
dmatrix_train <- xgb.DMatrix(data.train.predictors, label=data.train.label, nthread = 1)
# create model from training data
cv <- xgb.cv(
params = xgb.params,
data = dmatrix_train,
nrounds = 500,
nfold = 5,
early_stopping_rounds = 10,
verbose = 1,
showsd = TRUE,
print_every_n = 10
)
best_nrounds <- cv$best_iteration
booster <- xgb.train(
data = dmatrix_train,
nrounds = best_nrounds,
params = xgb.params
)
# testing
data.test.predictors = subset(data.test, select = c(age, menopause, size, grade, nodes, er, pr, year))
data.test.label = as.numeric(data.test[,"survtime"])
dmatrix_test <- xgb.DMatrix(data.test.predictors, label=data.test.label, nthread = nthread)
# predicting
xgb.importance(model=booster)
booster
# prediction output is the hazard ratio
pred <- predict(booster, data.test.predictors)
str(pred)
pred_leaf <- predict(booster, data.test.predictors, predleaf = TRUE)
str(pred_leaf)
# Predicting feature contributions to predictions:
# the result is an nsamples X (nfeatures + 1) matrix
pred_contr <- predict(booster, data.test.predictors, predcontrib = TRUE)
str(pred_contr)
# accuracy measures - bootstrap samples
set.seed(123)
n_boot <- 1000
n <- nrow(data.test)
# Create empty matrix
cindex_mat <- matrix(NA, nrow = n_boot, ncol = 4)
models <- c("Clinical_Cox", "XGB_Cox", "XGB_CPH", "XGB_Weibull")
colnames(cindex_mat) <- models
for (i in 1:n_boot) {
idx <- sample(1:n, replace = TRUE)
data.boot <- data.frame(data.test[idx, ])
pred_boot <- predict(booster, as.matrix(data.boot[, c("age", "menopause", "size", "grade", "nodes", "er", "pr", "year")]))
model_boot_cph         <- coxph(Surv(survtime, censdead) ~ age + grade + er + pr + size, data = data.boot, x=TRUE, y=TRUE)
model_boot_xgb_cox      <- coxph(Surv(survtime, censdead) ~ pred_boot, data = data.boot, x=TRUE, y=TRUE)
model_boot_xgb_cph      <- cph(Surv(survtime, censdead) ~ pred_boot, data = data.boot, x=TRUE, y=TRUE)
model_boot_xgb_weibull  <- psm(Surv(survtime, censdead) ~ pred_boot, data = data.boot, dist = "weibull", x=TRUE, y=TRUE)
cindex_mat[i, 1] <- concordance(model_boot_cph)$concordance
cindex_mat[i, 2] <- concordance(model_boot_xgb_cox)$concordance
cindex_mat[i, 3] <- model_boot_xgb_cph$stats["Dxy"]/2 + 0.5
cindex_mat[i, 4] <- model_boot_xgb_weibull$stats["Dxy"]/2 + 0.5
}
# Each column is a model
head(cindex_mat)
for (i in 1:n_boot) {
idx <- sample(1:n, replace = TRUE)
data.boot <- data.frame(data.test[idx, ])
data.boot$pred_boot <- predict(booster, as.matrix(data.boot[, c("age", "menopause", "size", "grade", "nodes", "er", "pr", "year")]))
model_boot_cph         <- coxph(Surv(survtime, censdead) ~ age + grade + er + pr + size, data = data.boot, x=TRUE, y=TRUE)
model_boot_xgb_cox      <- coxph(Surv(survtime, censdead) ~ pred_boot, data = data.boot, x=TRUE, y=TRUE, robust=TRUE)
model_boot_xgb_cph      <- cph(Surv(survtime, censdead) ~ pred_boot, data = data.boot, x=TRUE, y=TRUE)
model_boot_xgb_weibull  <- psm(Surv(survtime, censdead) ~ pred_boot, data = data.boot, dist = "weibull", x=TRUE, y=TRUE)
cindex_mat[i, 1] <- concordance(model_boot_cph)$concordance
cindex_mat[i, 2] <- concordance(model_boot_xgb_cox)$concordance
cindex_mat[i, 3] <- model_boot_xgb_cph$stats["Dxy"]/2 + 0.5
cindex_mat[i, 4] <- model_boot_xgb_weibull$stats["Dxy"]/2 + 0.5
}
# Each column is a model
head(cindex_mat)
xgb.params <- list(
booster = "gbtree",
eta = 0.05,
max_depth = 4,
gamma = 0.1,
subsample = 0.75,
colsample_bytree = 0.8,
objective = "survival:cox",
nthread = nthread,
eval_metric = "concordance-index"
)
#use 70% of dataset as training set and 30% as test set
sample <- sample(c(TRUE, FALSE), nrow(data), replace=TRUE, prob=c(0.7,0.3))
data.train  <- as.matrix(data[sample, ])
data.test   <- as.matrix(data[!sample, ])
data.train.predictors = subset(data.train, select = c(age, menopause, size, grade, nodes, er, pr, year))
data.train.label = as.numeric(data.train[,"survtime"])
dmatrix_train <- xgb.DMatrix(data.train.predictors, label=data.train.label, nthread = 1)
# create model from training data
cv <- xgb.cv(
params = xgb.params,
data = dmatrix_train,
nrounds = 500,
nfold = 5,
early_stopping_rounds = 10,
verbose = 1,
showsd = TRUE,
print_every_n = 10
)
best_nrounds <- cv$best_iteration
booster <- xgb.train(
data = dmatrix_train,
nrounds = best_nrounds,
params = xgb.params
)
xgb.params <- list(
booster = "gbtree",
eta = 0.05,
max_depth = 4,
gamma = 0.1,
min_child_weight = 5,
subsample = 0.75,
colsample_bytree = 0.8,
objective = "survival:cox",
nthread = nthread,
eval_metric = "cox-nloglik"
)
#use 70% of dataset as training set and 30% as test set
sample <- sample(c(TRUE, FALSE), nrow(data), replace=TRUE, prob=c(0.7,0.3))
data.train  <- as.matrix(data[sample, ])
data.test   <- as.matrix(data[!sample, ])
data.train.predictors = subset(data.train, select = c(age, menopause, size, grade, nodes, er, pr, year))
data.train.label = as.numeric(data.train[,"survtime"])
dmatrix_train <- xgb.DMatrix(data.train.predictors, label=data.train.label, nthread = 1)
# create model from training data
cv <- xgb.cv(
params = xgb.params,
data = dmatrix_train,
nrounds = 500,
nfold = 5,
early_stopping_rounds = 10,
verbose = 1,
showsd = TRUE,
print_every_n = 10
)
best_nrounds <- cv$best_iteration
booster <- xgb.train(
data = dmatrix_train,
nrounds = best_nrounds,
params = xgb.params
)
# testing
data.test.predictors = subset(data.test, select = c(age, menopause, size, grade, nodes, er, pr, year))
data.test.label = as.numeric(data.test[,"survtime"])
dmatrix_test <- xgb.DMatrix(data.test.predictors, label=data.test.label, nthread = nthread)
# predicting
xgb.importance(model=booster)
booster
# prediction output is the hazard ratio
pred <- predict(booster, data.test.predictors)
str(pred)
pred_leaf <- predict(booster, data.test.predictors, predleaf = TRUE)
str(pred_leaf)
# Predicting feature contributions to predictions:
# the result is an nsamples X (nfeatures + 1) matrix
pred_contr <- predict(booster, data.test.predictors, predcontrib = TRUE)
str(pred_contr)
# accuracy measures - bootstrap samples
set.seed(123)
n_boot <- 1000
n_boot <- 500
n <- nrow(data.test)
# Create empty matrix
cindex_mat <- matrix(NA, nrow = n_boot, ncol = 4)
models <- c("Clinical_Cox", "XGB_Cox", "XGB_CPH", "XGB_Weibull")
colnames(cindex_mat) <- models
for (i in 1:n_boot) {
idx <- sample(1:n, replace = TRUE)
data.boot <- data.frame(data.test[idx, ])
data.boot$pred_boot <- predict(booster, as.matrix(data.boot[, c("age", "menopause", "size", "grade", "nodes", "er", "pr", "year")]))
model_boot_cph         <- coxph(Surv(survtime, censdead) ~ age + grade + er + pr + size, data = data.boot, x=TRUE, y=TRUE)
model_boot_xgb_cox      <- coxph(Surv(survtime, censdead) ~ pred_boot, data = data.boot, x=TRUE, y=TRUE, robust=TRUE)
model_boot_xgb_cph      <- cph(Surv(survtime, censdead) ~ pred_boot, data = data.boot, x=TRUE, y=TRUE)
model_boot_xgb_weibull  <- psm(Surv(survtime, censdead) ~ pred_boot, data = data.boot, dist = "weibull", x=TRUE, y=TRUE)
cindex_mat[i, 1] <- concordance(model_boot_cph)$concordance
cindex_mat[i, 2] <- concordance(model_boot_xgb_cox)$concordance
cindex_mat[i, 3] <- model_boot_xgb_cph$stats["Dxy"]/2 + 0.5
cindex_mat[i, 4] <- model_boot_xgb_weibull$stats["Dxy"]/2 + 0.5
}
# Each column is a model
head(cindex_mat)
mean_cindex = apply(cindex_mat, 2, mean)
cindex_CI = apply(cindex_mat, 2, function(x) quantile(x, probs = c(0.025, 0.975)))
# new plotting window
par(mfrow = c(2, 2))
for (i in 1:4) {
hist(cindex_mat[, i], breaks = 30, main = models[i], xlab = "C-index")
abline(v = mean_cindex[i], col = "red", lwd = 2)
}
# brier score
# Step 1: Fit Kaplan-Meier to get baseline
fit.km <- survfit(surv.obj ~ 1)
xgb.params <- list(
booster = "gbtree",
eta = 0.1,
max_depth = 4,
gamma = 0.1,
subsample = 0.75,
colsample_bytree = 0.8,
objective = "survival:cox",
nthread = nthread,
eval_metric = "cox-nloglik"
)
#use 70% of dataset as training set and 30% as test set
sample <- sample(c(TRUE, FALSE), nrow(data), replace=TRUE, prob=c(0.7,0.3))
data.train  <- as.matrix(data[sample, ])
data.test   <- as.matrix(data[!sample, ])
data.train.predictors = subset(data.train, select = c(age, menopause, size, grade, nodes, er, pr, year))
data.train.label = as.numeric(data.train[,"survtime"])
dmatrix_train <- xgb.DMatrix(data.train.predictors, label=data.train.label, nthread = 1)
# create model from training data
cv <- xgb.cv(
params = xgb.params,
data = dmatrix_train,
nrounds = 500,
nfold = 5,
early_stopping_rounds = 10,
verbose = 1,
showsd = TRUE,
print_every_n = 10
)
best_nrounds <- cv$best_iteration
booster <- xgb.train(
data = dmatrix_train,
nrounds = best_nrounds,
params = xgb.params
)
# testing
data.test.predictors = subset(data.test, select = c(age, menopause, size, grade, nodes, er, pr, year))
data.test.label = as.numeric(data.test[,"survtime"])
dmatrix_test <- xgb.DMatrix(data.test.predictors, label=data.test.label, nthread = nthread)
# predicting
xgb.importance(model=booster)
booster
# prediction output is the hazard ratio
pred <- predict(booster, data.test.predictors)
str(pred)
pred_leaf <- predict(booster, data.test.predictors, predleaf = TRUE)
str(pred_leaf)
# Predicting feature contributions to predictions:
# the result is an nsamples X (nfeatures + 1) matrix
pred_contr <- predict(booster, data.test.predictors, predcontrib = TRUE)
str(pred_contr)
# accuracy measures - bootstrap samples
set.seed(123)
n_boot <- 500
n <- nrow(data.test)
# Create empty matrix
cindex_mat <- matrix(NA, nrow = n_boot, ncol = 4)
models <- c("Clinical_Cox", "XGB_Cox", "XGB_CPH", "XGB_Weibull")
colnames(cindex_mat) <- models
for (i in 1:n_boot) {
idx <- sample(1:n, replace = TRUE)
data.boot <- data.frame(data.test[idx, ])
data.boot$pred_boot <- predict(booster, as.matrix(data.boot[, c("age", "menopause", "size", "grade", "nodes", "er", "pr", "year")]))
model_boot_cph         <- coxph(Surv(survtime, censdead) ~ age + grade + er + pr + size, data = data.boot, x=TRUE, y=TRUE)
model_boot_xgb_cox      <- coxph(Surv(survtime, censdead) ~ pred_boot, data = data.boot, x=TRUE, y=TRUE, robust=TRUE)
model_boot_xgb_cph      <- cph(Surv(survtime, censdead) ~ pred_boot, data = data.boot, x=TRUE, y=TRUE)
model_boot_xgb_weibull  <- psm(Surv(survtime, censdead) ~ pred_boot, data = data.boot, dist = "weibull", x=TRUE, y=TRUE)
cindex_mat[i, 1] <- concordance(model_boot_cph)$concordance
cindex_mat[i, 2] <- concordance(model_boot_xgb_cox)$concordance
cindex_mat[i, 3] <- model_boot_xgb_cph$stats["Dxy"]/2 + 0.5
cindex_mat[i, 4] <- model_boot_xgb_weibull$stats["Dxy"]/2 + 0.5
}
# Each column is a model
head(cindex_mat)
mean_cindex = apply(cindex_mat, 2, mean)
cindex_CI = apply(cindex_mat, 2, function(x) quantile(x, probs = c(0.025, 0.975)))
idx <- sample(1:n, replace = TRUE)
idx
mean_cindex = apply(cindex_mat, 2, mean)
cindex_CI = apply(cindex_mat, 2, function(x) quantile(x, probs = c(0.025, 0.975)))
cindex_CI
# new plotting window
par(mfrow = c(2, 2))
for (i in 1:4) {
hist(cindex_mat[, i], breaks = 30, main = models[i], xlab = "C-index")
abline(v = mean_cindex[i], col = "red", lwd = 2)
}
# brier score
# Step 1: Fit Kaplan-Meier to get baseline
fit.km <- survfit(surv.obj ~ 1)
ggsurvplot(fit.km, data=data.frame(data.test))
# Step 2: Interpolate baseline survival at required times
times <- seq(365, 365*5, by = 365)
# baseline survival probabilities
S0_t <- summary(fit.km, times = times)$surv
# survival probabilities
S_pred <- outer(pred, S0_t, FUN = function(hr, s0) s0^hr)
test_data <- data.frame(data.test)
test_data$pred = pred
# brier score calc
brier <- pec(
object = list("coxph" = model.cox,
"xgcoxph" = model.xg.cox,
"xgcph" = model.xg.cph,
"xgweibull" = model.xg.weibull),    # <- Matrix
formula = Surv(survtime, censdead) ~ 1,
data = test_data,  # <- Match formula
times = times,
cens.model = "cox",
splitMethod = "Boot632",
B = 1000
)
plot(brier)
for (i in 1:n_boot) {
idx <- sample(1:n, replace = TRUE)
data.boot <- data.frame(data.test[idx, ])
data.boot$pred_boot <- predict(booster, as.matrix(data.boot[, c("age", "menopause", "size", "grade", "nodes", "er", "pr", "year")]))
model_boot_cph         <- coxph(Surv(survtime, censdead) ~ age + grade + er + pr + size, data = data.boot, x=TRUE, y=TRUE)
model_boot_xgb_cox      <- coxph(Surv(survtime, censdead) ~ pred_boot, data = data.boot, x=TRUE, y=TRUE, robust=TRUE)
model_boot_xgb_cph      <- cph(Surv(survtime, censdead) ~ log(pred_boot), data = data.boot, x=TRUE, y=TRUE)
model_boot_xgb_weibull  <- psm(Surv(survtime, censdead) ~ pred_boot, data = data.boot, dist = "weibull", x=TRUE, y=TRUE)
cindex_mat[i, 1] <- concordance(model_boot_cph)$concordance
cindex_mat[i, 2] <- concordance(model_boot_xgb_cox)$concordance
cindex_mat[i, 3] <- model_boot_xgb_cph$stats["Dxy"]/2 + 0.5
cindex_mat[i, 4] <- model_boot_xgb_weibull$stats["Dxy"]/2 + 0.5
}
# Each column is a model
head(cindex_mat)
for (i in 1:n_boot) {
idx <- sample(1:n, replace = TRUE)
data.boot <- data.frame(data.test[idx, ])
data.boot$pred_boot <- predict(booster, as.matrix(data.boot[, c("age", "menopause", "size", "grade", "nodes", "er", "pr", "year")]))
model_boot_cph         <- coxph(Surv(survtime, censdead) ~ age + grade + er + pr + size, data = data.boot, x=TRUE, y=TRUE)
model_boot_xgb_cox      <- coxph(Surv(survtime, censdead) ~ pred_boot, data = data.boot, x=TRUE, y=TRUE, robust=TRUE)
model_boot_xgb_cph      <- cph(Surv(survtime, censdead) ~ -pred_boot, data = data.boot, x=TRUE, y=TRUE)
model_boot_xgb_weibull  <- psm(Surv(survtime, censdead) ~ pred_boot, data = data.boot, dist = "weibull", x=TRUE, y=TRUE)
cindex_mat[i, 1] <- concordance(model_boot_cph)$concordance
cindex_mat[i, 2] <- concordance(model_boot_xgb_cox)$concordance
cindex_mat[i, 3] <- model_boot_xgb_cph$stats["Dxy"]/2 + 0.5
cindex_mat[i, 4] <- model_boot_xgb_weibull$stats["Dxy"]/2 + 0.5
}
# Each column is a model
head(cindex_mat)
# Create empty matrix
cindex_mat <- matrix(NA, nrow = n_boot, ncol = 4)
models <- c("Clinical_Cox", "XGB_Cox")
# Create empty matrix
cindex_mat <- matrix(NA, nrow = n_boot, ncol = 2)
models <- c("Clinical_Cox", "XGB_Cox")
colnames(cindex_mat) <- models
for (i in 1:n_boot) {
idx <- sample(1:n, replace = TRUE)
data.boot <- data.frame(data.test[idx, ])
data.boot$pred_boot <- predict(booster, as.matrix(data.boot[, c("age", "menopause", "size", "grade", "nodes", "er", "pr", "year")]))
model_boot_cox        <- coxph(Surv(survtime, censdead) ~ age + grade + er + pr + size, data = data.boot, x=TRUE, y=TRUE)
model_boot_xgb_cox      <- coxph(Surv(survtime, censdead) ~ pred_boot, data = data.boot, x=TRUE, y=TRUE, robust=TRUE)
model_boot_xgb_weibull  <- psm(Surv(survtime, censdead) ~ pred_boot, data = data.boot, dist = "weibull", x=TRUE, y=TRUE)
cindex_mat[i, 1] <- concordance(model_boot_cox)$concordance
cindex_mat[i, 2] <- concordance(model_boot_xgb_cox)$concordance
}
head(cindex_mat)
source("C:/Users/loucu/Coding_Projects/breast-cancer-cpm-validation/example_random_forest.R", echo=TRUE)
source("C:/Users/loucu/Coding_Projects/breast-cancer-cpm-validation/example_random_forest.R", echo=TRUE)
get.cindex(time = testdata$survtime, censoring = testdata$censdead, predicted = rf.model.all$predicted.oob)
View(testdata)
source("C:/Users/loucu/Coding_Projects/breast-cancer-cpm-validation/example_random_forest.R", echo=TRUE)
source("C:/Users/loucu/Coding_Projects/breast-cancer-cpm-validation/example_random_forest.R", echo=TRUE)
get.cindex(time = testdata$survtime, censoring = testdata$censdead, predicted = rf.model.all$predicted.oob)
# take a delete-d-jackknife procedure for vimp
vimpCI <- extract.subsample(oo)$var.jk.sel.Z
vimpCI
# Confidence Intervals for VIMP
plot.subsample(oo)
# nodes partial plot
plot.variable(rf.model.all, xvar.names = "nodes", partial = TRUE)
# pr partial plot
plot.variable(rf.model.all, xvar.names = "pr", partial = TRUE)
# er partial plot
plot.variable(rf.model.all, xvar.names = "er", partial = TRUE)
# age partial plot
plot.variable(rf.model.all, xvar.names = "age", partial = TRUE)
# size partial plot
plot.variable(rf.model.all, xvar.names = "size", partial = TRUE)
plot.variable(rf.model.all, partial=T)
get.cindex(time = testdata$survtime, censoring = testdata$censdead, predicted = rf.model.all$predicted.oob)
install.packages("ROCR")
# Plot ROC
perf <- performance(pred, measure = "tpr", x.measure = "fpr")
library(ROCR)
# Plot ROC
perf <- performance(pred, measure = "tpr", x.measure = "fpr")
# prediction output is the hazard ratio
pred <- predict(booster, data.test.predictors)
demo(ROCR)
# Predict and plot ROC
pred <- prediction(data.test.predictors, data.test.label)
# Predict and plot ROC
pred <- prediction(booster, data.test.label)
View(ROCR.hiv)
# Predict and plot ROC
pred <- prediction(pred, data.test.label)
# prediction output is the hazard ratio
pred <- predict(booster, data.test.predictors)
# Predict and plot ROC
pred <- prediction(pred, data.test.label)
# accuracy measures - bootstrap samples
set.seed(123)
n_boot <- 1000
n <- nrow(data.test)
# Create empty matrix
cindex_mat <- matrix(NA, nrow = n_boot, ncol = 2)
models <- c("Clinical_Cox", "XGB_Cox", "XGB_Coxexp", "XGB_Coxlog", "XGB_Coxsq")
colnames(cindex_mat) <- models
# Create empty matrix
cindex_mat <- matrix(NA, nrow = n_boot, ncol = 5)
models <- c("Clinical_Cox", "XGB_Cox", "XGB_Coxexp", "XGB_Coxlog", "XGB_Coxsq")
colnames(cindex_mat) <- models
for (i in 1:n_boot) {
idx <- sample(1:n, replace = TRUE)
data.boot <- data.frame(data.test[idx, ])
data.boot$pred_boot <- predict(booster, as.matrix(data.boot[, c("age", "menopause", "size", "grade", "nodes", "er", "pr", "year")]))
model_boot_cox        <- coxph(Surv(survtime, censdead) ~ age + grade + er + pr + size, data = data.boot, x=TRUE, y=TRUE)
model_boot_xgb_cox      <- coxph(Surv(survtime, censdead) ~ pred_boot, data = data.boot, x=TRUE, y=TRUE, robust=TRUE)
model_boot_xgb_cox.exp      <- coxph(Surv(survtime, censdead) ~ exp(pred_boot), data = data.boot, x=TRUE, y=TRUE, robust=TRUE)
model_boot_xgb_cox.log      <- coxph(Surv(survtime, censdead) ~ log(pred_boot), data = data.boot, x=TRUE, y=TRUE, robust=TRUE)
model_boot_xgb_cox.sq      <- coxph(Surv(survtime, censdead) ~ (pred_boot).^2, data = data.boot, x=TRUE, y=TRUE, robust=TRUE)
for (i in 1:n_boot) {
idx <- sample(1:n, replace = TRUE)
data.boot <- data.frame(data.test[idx, ])
data.boot$pred_boot <- predict(booster, as.matrix(data.boot[, c("age", "menopause", "size", "grade", "nodes", "er", "pr", "year")]))
model_boot_cox        <- coxph(Surv(survtime, censdead) ~ age + grade + er + pr + size, data = data.boot, x=TRUE, y=TRUE)
model_boot_xgb_cox      <- coxph(Surv(survtime, censdead) ~ pred_boot, data = data.boot, x=TRUE, y=TRUE, robust=TRUE)
model_boot_xgb_cox.exp      <- coxph(Surv(survtime, censdead) ~ exp(pred_boot), data = data.boot, x=TRUE, y=TRUE, robust=TRUE)
model_boot_xgb_cox.log      <- coxph(Surv(survtime, censdead) ~ log(pred_boot), data = data.boot, x=TRUE, y=TRUE, robust=TRUE)
model_boot_xgb_cox.sq      <- coxph(Surv(survtime, censdead) ~ (pred_boot)^2, data = data.boot, x=TRUE, y=TRUE, robust=TRUE)
cindex_mat[i, 1] <- concordance(model_boot_cox)$concordance
cindex_mat[i, 2] <- concordance(model_boot_xgb_cox)$concordance
cindex_mat[i, 3] <- concordance(model_boot_xgb_cox.exp)$concordance
cindex_mat[i, 4] <- concordance(model_boot_xgb_cox.log)$concordance
cindex_mat[i, 5] <- concordance(model_boot_xgb_cox.sq)$concordance
}
head(cindex_mat)
# Create empty matrix
cindex_mat <- matrix(NA, nrow = n_boot, ncol = 2)
models <- c("Clinical_Cox", "XGB_Cox")
colnames(cindex_mat) <- models
for (i in 1:n_boot) {
idx <- sample(1:n, replace = TRUE)
data.boot <- data.frame(data.test[idx, ])
data.boot$pred_boot <- predict(booster, as.matrix(data.boot[, c("age", "menopause", "size", "grade", "nodes", "er", "pr", "year")]))
model_boot_cox        <- coxph(Surv(survtime, censdead) ~ age + grade + er + pr + size, data = data.boot, x=TRUE, y=TRUE)
model_boot_xgb_cox      <- coxph(Surv(survtime, censdead) ~ pred_boot, data = data.boot, x=TRUE, y=TRUE, robust=TRUE)
cindex_mat[i, 1] <- concordance(model_boot_cox)$concordance
cindex_mat[i, 2] <- concordance(model_boot_xgb_cox)$concordance
}
View(gbcsCS)
d <- data(gbcsCS)
source("C:/Users/loucu/Coding_Projects/breast-cancer-cpm-validation/predict-v30-r/inst/defpackage.R")
source("C:/Users/loucu/Coding_Projects/breast-cancer-cpm-validation/R/predict-v30-r/inst/defpackage.R")
library(condSURV)
library(lubridate)
library(here)
data(gbcsCS)
data<- gbcsCS
View(data)
write.csv(data, "gbcsCS.csv")
